use crate::chunks::METATILES_PER_CHUNK;
use crate::tiles::Tile;
use crate::tileset::MetatileEntry;
use smallvec::SmallVec;
use std::convert::TryFrom;
use std::env;
use std::fmt::Display;
use std::fs::File;
use std::path::Path;
use std::process;

mod chunks;
mod palettes;
mod tiles;
mod tileset;

const NB_CHUNKS_W: u32 = 16;
const NB_CHUNKS_H: u32 = 16;
const NB_COMMON_TILES: usize = 64;

fn main() {
    let mut args = env::args();

    let prog_name = args
        .next()
        .expect("What, the program doesn't even have an argv[0]?");
    let tmx_path = expect_arg(args.next(), &prog_name);
    let pal_path = expect_arg(args.next(), &prog_name);
    let tiles_path = expect_arg(args.next(), &prog_name);
    let map_path = expect_arg(args.next(), &prog_name);
    let pal_map_path = expect_arg(args.next(), &prog_name);
    let map_name = expect_arg(args.next(), &prog_name);
    let tileset_img_width = match usize::from_str_radix(&expect_arg(args.next(), &prog_name), 10) {
        Ok(width) => width,
        Err(err) => {
            eprintln!("Tileset image width isn't a valid base 10 number: {}", err);
            process::exit(1);
        }
    };
    if args.next().is_some() {
        usage(&prog_name);
        process::exit(1);
    }

    let map = match tiled::parse_file(Path::new(&tmx_path)) {
        Err(err) => {
            eprintln!("Error parsing tiled file \"{}\": {}", tmx_path, err);
            process::exit(1);
        }
        Ok(file) => file,
    };
    let pal_file = open_required_file(&pal_path);
    let tiles_file = open_required_file(&tiles_path);
    // NOTE: contains interleaved tilemap & attrmap
    let map_file = open_required_file(&map_path);
    let pal_map_file = open_required_file(&pal_map_path);

    let palettes = match palettes::from_sfc_json(pal_file) {
        Ok(palettes) => palettes,
        Err(err) => {
            eprintln!("Error reading palettes from \"{}\": {}", pal_path, err);
            process::exit(1);
        }
    };

    // Read all tiles
    let tiles = match tiles::from_file(tiles_file) {
        Err(err) => {
            eprintln!("Error reading tiles from \"{}\": {}", tiles_path, err);
            process::exit(1);
        }
        Ok(tiles) => tiles,
    };
    if tiles.len() > 512 {
        eprintln!(
            "FIXME: SuperFamiconv does not handle outputting tile IDs for more than 512 tiles (we have {})",
            tiles.len()
        );
        process::exit(1);
    }

    // Build array of map's metatiles
    if tileset_img_width % 16 != 0 {
        eprintln!(
            "Tileset image width ({}) must be a multiple of 16 pixels",
            tileset_img_width
        );
        process::exit(1);
    }
    let metatiles = match tileset::from_files(map_file, pal_map_file, tileset_img_width / 8) {
        Err(err) => {
            eprintln!(
                "Error reading metatiles from {} and {}: {}",
                map_path, pal_map_path, err
            );
            process::exit(1);
        }
        Ok(metatiles) => metatiles,
    };

    // Generate chunks (their metatile definitions, then their metatilemaps)
    let mut tile_ref_counts = vec![0; tiles.len()]; // Init ref counts
    let (chunks, chunk_map) = match chunks::gen_from_map(&map, &metatiles, &mut tile_ref_counts) {
        Err(err) => {
            eprintln!("Error generating chunk data: {}", err);
            process::exit(1);
        }
        Ok(ret) => ret,
    };

    // Assign tiles to the "common" set, assign the rest to chunks
    let common_tiles_ids: Vec<_> = if tiles.len() <= NB_COMMON_TILES {
        (0..tiles.len()).collect()
    } else {
        (0..NB_COMMON_TILES)
            .map(|_| {
                // Find the tile ID with the highest ref count
                let i = (1..tile_ref_counts.len()).fold(0, |n, i| {
                    if tile_ref_counts[n] < tile_ref_counts[i] {
                        i
                    } else {
                        n
                    }
                });
                // Remove all refs to this tile
                tile_ref_counts[i] = 0;
                // Return that ID
                i
            })
            .collect()
    };

    // Output the data

    if !map_name.is_ascii() {
        eprintln!("Map name must be ASCII-only, otherwise RGBASM will error out");
        process::exit(1);
    }
    let map_name_titlecase = make_ascii_titlecase(&map_name);

    println!(
        "; This file is auto-generated by {}. Manual edits will be lost!",
        prog_name
    );
    println!("MAP_{} rb 1", map_name.to_uppercase());
    println!("\tEXPORT MAP_{}", map_name.to_uppercase());
    println!(
        "\tdb BANK({}Map), HIGH({}Map)",
        map_name_titlecase, map_name_titlecase
    );

    println!("\tPUSHS");
    // For the map data specification, see doc/map.md
    println!("SECTION \"{} map\", ROMX,ALIGN[8]", map_name);
    println!(
        "\tdw ${:04x} ; Pal table size",
        u16::try_from(
            palettes
                .iter()
                .fold(0, |size, palette| size + palette.0.len() * 3) // 3 bytes per color
        )
        .unwrap()
    );
    println!("{}Map:", map_name_titlecase);

    // Chunk tables
    let print_chunk_map = |func| {
        for row in &chunk_map {
            for (i, id) in row.iter().enumerate() {
                print!(
                    "{} {}({}Chunk{})",
                    if i == 0 { "\tdb" } else { "," },
                    func,
                    map_name_titlecase,
                    id
                );
            }
            println!();
        }
    };
    println!(".chunkHiMap ; For the chunk data specification, see doc/chunk.md");
    print_chunk_map("HIGH");
    println!(".chunkBankMap");
    print_chunk_map("BANK");

    // Palette array
    println!(".palettes ; In GRB24 format");
    for (i, palette) in palettes.iter().enumerate() {
        println!("\t; Palette ${:02x}", i);
        for color in &palette.0 {
            println!(
                "\tdb ${:02x}, ${:02x}, ${:02x}",
                color.green, color.red, color.blue
            );
        }
    }

    // Chunks
    for (i, chunk) in chunks.iter().enumerate() {
        println!("SECTION \"{} chunk #{}\", ROMX,ALIGN[8]", map_name, i);
        println!(
            "\tdb ${:02x} ; Metatile defs size minus 1",
            chunk.metatile_ids.len() * 4 - 1
        );
        println!("{}Chunk{}:", map_name_titlecase, i);

        println!(".metatileMap");
        let mut refd_tiles: SmallVec<[usize; METATILES_PER_CHUNK]> = SmallVec::new();
        let mut ref_tile = |metatile_entry: &MetatileEntry| {
            // If tile hasn't been referenced in common tiles, ref it
            if tile_ref_counts[usize::from(metatile_entry.id)] != 0 {
                // If tile isn't already in vec, add it
                if !refd_tiles.contains(&metatile_entry.id.into()) {
                    refd_tiles.push(metatile_entry.id.into());
                }
            }
        };
        for row in &chunk.map {
            for (i, entry) in row.iter().enumerate() {
                // TODO: support static IDs
                let metatile = &metatiles[usize::from(chunk.metatile_ids[usize::from(entry.id)])];
                ref_tile(&metatile.top_left);
                ref_tile(&metatile.top_right);
                ref_tile(&metatile.bottom_left);
                ref_tile(&metatile.botom_right);

                print!(
                    "{} ${:02x}",
                    if i == 0 { "\tdb" } else { "," },
                    u8::from(entry)
                );
            }
            println!();
        }
        assert!(refd_tiles.len() <= METATILES_PER_CHUNK);

        // Metatile definitions
        let print_metatile = |entry: &MetatileEntry| {
            let tile_id = common_tiles_ids
                .iter()
                .enumerate()
                .find(|(_, &id)| id == usize::from(entry.id))
                .map_or_else(
                    || {
                        *refd_tiles
                            .iter()
                            .enumerate()
                            .find(|(_, &id)| id == usize::from(entry.id))
                            .expect("Tiles should be either common or per-chunk!?")
                            .1
                    },
                    |(i, _)| i | 0xC0,
                );
            let attrs = u8::from(entry.xflip) << 5 | u8::from(entry.yflip) << 6;
            println!(
                "\tdb ${:02x}, ${:02x}, ${:02x}, ${:02x}",
                tile_id, entry.pal_id, attrs, 0
            );
        };
        println!(".metatiles ; For the metatile data specification, see doc/metatile.md");
        for (i, &id) in chunk.metatile_ids.iter().enumerate() {
            println!("\t; Metatile #{}", i);
            let metatile = &metatiles[usize::from(id)];
            print_metatile(&metatile.top_left);
            print_metatile(&metatile.top_right);
            print_metatile(&metatile.bottom_left);
            print_metatile(&metatile.botom_right);
        }

        // Chunk tiles ptr
        if !refd_tiles.is_empty() {
            println!("\tdw {}Chunk{}Tiles", map_name_titlecase, i);
            println!("\tdb BANK({}Chunk{}Tiles)", map_name_titlecase, i);
        } else {
            println!("\tdw 0 ; No tiles");
        }
        // TODO: other attributes

        // Chunk tiles block
        if !refd_tiles.is_empty() {
            print_tile_block(
                &tiles,
                refd_tiles.as_slice(),
                &map_name_titlecase,
                &format!("Chunk{}", i),
            );
        }
    }

    // Common tiles
    print_tile_block(&tiles, &common_tiles_ids, &map_name_titlecase, "Common");

    println!("\tPOPS");
}

fn print_tile_block(tiles: &[Tile], ids: &[usize], map_name_titlecase: &str, name: &str) {
    println!("SECTION \"{} tiles\", ROMX,ALIGN[4,15]", name);
    println!("{}{}Tiles:", map_name_titlecase, name);
    assert!(
        ids.len() <= 128,
        "Can only transfer up to 128 tiles at once, not {}",
        ids.len()
    );
    println!("\tdb ${:02x}", u8::try_from(ids.len()).unwrap() - 1);
    for &id in ids {
        for (i, &entry) in tiles[id].0.iter().enumerate() {
            print!("{} ${:02x}", if i == 0 { "\tdb" } else { "," }, entry);
        }
        println!();
    }
}

fn expect_arg(arg: Option<String>, prog_name: &str) -> String {
    arg.unwrap_or_else(|| {
        usage(prog_name);
        process::exit(1);
    })
}

fn usage(prog_name: &str) {
    eprintln!(
        "Usage: {} <tmx file> <tileset pal JSON file> <tileset 2bpp file> <tileset map file> <palette map file> <map name> <tileset image width>",
        prog_name
    );
    eprintln!(
        "Example: {} src/res/maps/overworld/map.tmx res/maps/overworld/tileset.pal.json res/maps/overworld/tileset.2bpp res/maps/overworld/tileset.map res/maps/overworld/tileset.palmap overworld 128",
        prog_name
    );
}

fn open_required_file<P: AsRef<Path> + Display>(path: P) -> File {
    match File::open(&path) {
        Err(err) => {
            eprintln!("Error: Failed to open \"{}\": {}", path, err);
            process::exit(1);
        }
        Ok(file) => file,
    }
}

fn make_ascii_titlecase(original: &str) -> String {
    // Reserved size is a bit eager, but only a few bytes too many, typically
    let mut titlecase = String::with_capacity(original.len());

    let mut to_upper = true;
    for c in original.chars() {
        if to_upper {
            titlecase.push(c.to_ascii_uppercase());
            to_upper = false;
        } else if c == '_' {
            to_upper = true;
        } else {
            titlecase.push(c.to_ascii_lowercase());
        }
    }
    titlecase
}
